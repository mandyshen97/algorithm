## 算法题

## 剪绳子（动态规划，贪心算法，划分）
- 题目描述

给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[1],...,k[m]。请问k[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
- 输入描述:

输入一个数n，意义见题面。（2 <= n <= 60）
- 输出描述:

输出答案。
- 示例1

输入 8

输出 18

- 解题方法与思路
```javascript
function cutRope(number) {
  // write code here
  // dp[i]表示长度为i的绳子剪切后的最大乘积。本题最终变为求dp[number]
  // 将长度为i的绳子分为长度为j和 i-j，那么i 的最优解就是j的最优解和i-j的最优解的乘积。
  // 长度为j的绳子的最优解（不一定分段后会更大，例如对于长度为3的绳子，分段后的最大乘积为1，不分段则为3）
  let dp = [];
  dp[1] = 0; // 由于m>1，也就是必须要分段，所以总长度为1无法分段
  dp[2] = 1; // 总长度为2，只能分成1+1=2，乘积为1
  // dp[3] = 2;// 总长度为3，可以分成1+1+1，1+2，最大乘积为3
  for (let i = 3; i <= number; i++) {
    let res = 0;
    for (let j = 1; j < i; j++) {
      let a = Math.max(j, dp[j]); // 长度为j的绳子的最优解（不一定分段后会更大，例如对于长度为3的绳子，分段后的最大乘积为1，不分段则为3）
      let b = Math.max(i - j, dp[i - j]);
      let t = a * b;
      res = t > res ? t : res;
    }
    dp[i] = res;
  }
  return dp[number];
}
module.exports = {
  cutRope: cutRope,
};

```
